{"version":3,"sources":["Nodes.js","Algorithms/Maze/RecursiveDivision.js","Algorithms/Search algo/bfs.js","PathFindingView.js","header.js","App.js","index.js"],"names":["Nodes","nodeClass","this","props","start","end","wall","visited","visitedRealTime","path","className","id","row","col","onMouseDown","onMouseEnter","onMouseUp","Component","recursiveDivisionMaze","grid","startNode","finishNode","height","width","walls","getRecursiveWalls","range","len","result","i","push","vertical","horizontal","dir","num","length","generateOddRandomNumber","addWall","slice","indexOf","array","max","randomNum","Math","floor","random","a","isStartFinish","tempWalls","temp","splice","generateRandomNumber","getResultPath","current","resultPath","previous","reverse","boardWidth","boardHeight","Header","handleMazeChange","event","setState","maze","target","value","handleAlgorithmChange","algorithm","selectedAlgorithm","state","algo","paused","clearVisited","sentPath","visitedPath","neighbors","Set","cacheNeighbours","shift","add","no","top","has","bottom","left","right","bfs","pop","dfs","console","log","startNeighbors","endNeighbors","startCache","endCache","concat","endNode","bidirectionalSearch","clearSelectedAlgorithm","togglePaused","clearGrid","sentResult","clone","Object","assign","change","searchAlgorithm","onChange","onClick","mazeAlgorithm","delay","ms","Promise","resolve","setTimeout","PathFindingView","mouseDownFunctions","rows","cols","e","board","mousePressed","currentGrid","updateIndex","mouseEnterFunction","changed","mouseUpFunction","window","innerWidth","innerHeight","arr","currentNode","cname","document","getElementById","j","condition","resultArray","animateWalls","solution","realTimePath","animatePath","visitedArray","solutionArray","index","toggleChanged","togglePausedFunction","changeStateFunction","content","update","$set","NodeComponent","map","rowKeys","colKeys","newVal","val","getResultArray","getVisitedArray","unselectable","cellSpacing","counter","rowArray","colArray","createNode","App","React","ReactDOM","render"],"mappings":"4PAmBeA,E,4JAdX,WAAS,IAAD,OACEC,EAAYC,KAAKC,MAAMC,MAAQ,kBAAqBF,KAAKC,MAAME,IAAM,gBAAkBH,KAAKC,MAAMG,KAAO,iBAAmBJ,KAAKC,MAAMI,QAAU,oBAAsBL,KAAKC,MAAMK,gBAAkB,qBAAuBN,KAAKC,MAAMM,KAAO,yBAA2B,OAC9Q,OACI,oBAAIC,UAAaT,EACjBU,GAAE,cAAWT,KAAKC,MAAMS,IAAtB,gBAAiCV,KAAKC,MAAMU,KAC9CC,YAAe,kBAAM,EAAKX,MAAMW,YAAY,EAAKX,MAAMS,IAAI,EAAKT,MAAMU,MACtEE,aAAgB,kBAAM,EAAKZ,MAAMY,aAAa,EAAKZ,MAAMS,IAAI,EAAKT,MAAMU,MACxEG,UAAa,kBAAM,EAAKb,MAAMa,mB,GATtBC,a,iBCHL,SAASC,EAAsBC,EAAMC,EAAWC,EAAYC,EAAQC,GAC/E,IAAKH,IAAcC,GAAcD,IAAcC,EAC3C,OAAO,EAEX,IAEIG,EAAQ,GAEZ,OADAC,EAHeC,EAAMH,GACJG,EAAMJ,GAEiBH,EAAMC,EAAWC,EAAYG,GAC9DA,EAGX,SAASE,EAAMC,GAEX,IADA,IAAIC,EAAS,GACJC,EAAI,EAAGA,EAAIF,EAAKE,IACrBD,EAAOE,KAAKD,GAEhB,OAAOD,EAMX,SAASH,EAAkBM,EAAUC,EAAYb,EAAMC,EAAWC,EAAYG,GAI1E,IAAIS,EACAC,EAJAH,EAASI,OAAS,GAAKH,EAAWG,OAAS,IAK3CJ,EAASI,OAASH,EAAWG,SAC7BF,EAAM,EACNC,EAAME,EAAwBL,IAE9BA,EAASI,QAAUH,EAAWG,SAC9BF,EAAM,EACNC,EAAME,EAAwBJ,IAGtB,IAARC,GACAI,EAAQlB,EAAMc,EAAKC,EAAKH,EAAUC,EAAYZ,EAAWC,EAAYG,GACrEC,EACIM,EAASO,MAAM,EAAGP,EAASQ,QAAQL,IACnCF,EACAb,EACAC,EACAC,EACAG,GAEJC,EACIM,EAASO,MAAMP,EAASQ,QAAQL,GAAO,GACvCF,EACAb,EACAC,EACAC,EACAG,KAGJa,EAAQlB,EAAMc,EAAKC,EAAKH,EAAUC,EAAYZ,EAAWC,EAAYG,GACrEC,EACIM,EACAC,EAAWM,MAAM,EAAGN,EAAWO,QAAQL,IACvCf,EACAC,EACAC,EACAG,GAEJC,EACIM,EACAC,EAAWM,MAAMN,EAAWO,QAAQL,GAAO,GAC3Cf,EACAC,EACAC,EACAG,KAKZ,SAASY,EAAwBI,GAC7B,IAAIC,EAAMD,EAAML,OAAS,EACrBO,EACAC,KAAKC,MAAMD,KAAKE,UAAYJ,EAAM,IAClCE,KAAKC,MAAMD,KAAKE,UAAYJ,EAAM,IAQtC,OAPIC,EAAY,IAAM,IACdA,IAAcD,EACdC,GAAa,EAEbA,GAAa,GAGdF,EAAME,G,SAMFL,E,4FAAf,WAAuBlB,EAAMc,EAAKC,EAAKH,EAAUC,EAAYZ,EAAWC,EAAYG,GAApF,mCAAAsB,EAAA,yDACQC,GAAgB,EAChBC,EAAY,GACJ,IAARf,EAHR,oBAIkC,IAAtBD,EAAWG,OAJvB,+DAKyBH,GALzB,+DAKiBiB,EALjB,WAO0B7B,EAAUR,KAAOsB,IAAQd,EAAUP,KAC5CoC,IAAS5B,EAAWT,KAAOsB,IAAQb,EAAWR,KAR/D,wBAUgBkC,GAAgB,EAVhC,gCAaYC,EAAUlB,KAAK,CAACmB,EAAMf,IAblC,0KAgBgC,IAApBH,EAASI,OAhBrB,iEAiByBJ,GAjBzB,8DAiBiBkB,EAjBjB,UAmBiBf,IAAQd,EAAUR,KAAOqC,IAAS7B,EAAUP,KAC5CqB,IAAQb,EAAWT,KAAOqC,IAAS5B,EAAWR,KApB/D,wBAsBgBkC,GAAgB,EAtBhC,gCAyBYC,EAAUlB,KAAK,CAACI,EAAKe,IAzBjC,iJA+BI,IAHKF,GACDC,EAAUE,OAAOC,EAAqBH,EAAUb,QAAS,GAE7D,MAAiBa,EAAjB,eAAS1C,EAAmB,KACxBkB,EAAMM,KAAKxB,GAhCnB,+E,sBAoCA,SAAS6C,EAAqBV,GAC1B,IAAIC,EACAC,KAAKC,MAAMD,KAAKE,UAAYJ,EAAM,IAClCE,KAAKC,MAAMD,KAAKE,UAAYJ,EAAM,IAQtC,OAPIC,EAAY,IAAM,IACdA,IAAcD,EACdC,GAAa,EAEbA,GAAa,GAGdA,ECsCX,SAASU,EAAcjC,EAAMkC,GAEzB,IADA,IAAIC,EAAa,GACkC,OAA5CnC,EAAKkC,EAAQzC,KAAKyC,EAAQxC,KAAK0C,UAC7BpC,EAAKkC,EAAQzC,KAAKyC,EAAQxC,KAAKT,OAAUe,EAAKkC,EAAQzC,KAAKyC,EAAQxC,KAAKR,KACzEiD,EAAWxB,KAAK,CAACuB,EAAQzC,IAAKyC,EAAQxC,MAE1CwC,EAAUlC,EAAKkC,EAAQzC,KAAKyC,EAAQxC,KAAK0C,SAE7C,OAAOD,EAAWE,U,ICrLlBC,EACAC,ECHiBC,E,kDACjB,WAAYxD,GAAO,IAAD,8BACd,cAAMA,IAOVyD,iBAAmB,SAACC,GAChB,EAAKC,SAAS,CAACC,KAAOF,EAAMG,OAAOC,SATrB,EAWlBC,sBAAwB,SAACL,GACrB,EAAKC,SAAS,CAACK,UAAYN,EAAMG,OAAOC,MAAOG,kBAAoBP,EAAMG,OAAOC,SAVhF,EAAKI,MAAQ,CACTF,UAAY,MACZJ,KAAO,gBACPK,kBAAoB,IALV,E,0DAelB,WACIlE,KAAK4D,SAAS,CAACM,kBAAoB,O,6BAGvC,SAAgBE,EAAKnD,GACjB,IAAIjB,KAAKC,MAAMoE,OACX,OAAOD,GACH,IAAK,MAAQpE,KAAKC,MAAMqE,eACxBtE,KAAK4D,SAAS,CAACM,kBAAoB,QACnClE,KAAKC,MAAMsE,SF7B3B,SAAatD,EAAMf,GAKf,IAJA,IAAIsE,EAAc,GACdC,EAAY,CAACvE,GACbG,EAAU,IAAIqE,IACdC,EAAkB,IAAID,IACnBD,EAAUxC,QAAQ,CACrB,IAAIkB,EAAUsB,EAAUG,QACxB,GAAIzB,EAAQhD,IACR,MAAO,CAACqE,EAAatB,EAAcjC,EAAMkC,MAEpCA,EAAQ/C,MAAS+C,EAAQjD,OAASiD,EAAQ/C,QAC3CC,EAAQwE,IAAI1B,EAAQ2B,IACpBH,EAAgBE,IAAI1B,EAAQ2B,IAC5BN,EAAY5C,KAAK,CAACuB,EAAQzC,IAAKyC,EAAQxC,MAEpB,MAAfwC,EAAQ4B,KAAgB1E,EAAQ2E,IAAI/D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,KAAQH,EAAgBK,IAAI/D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,MAC9H7D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAK0C,SAAWF,EAC1CwB,EAAgBE,IAAI5D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,IACnDL,EAAU7C,KAAKX,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,OAEvB,MAAlBwC,EAAQ8B,QAAmB5E,EAAQ2E,IAAI/D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,KAAQH,EAAgBK,IAAI/D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,MACvIH,EAAgBE,IAAI5D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,IACtD7D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAK0C,SAAWF,EAC7CsB,EAAU7C,KAAKX,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,OAE5B,MAAhBwC,EAAQ+B,MAAiB7E,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,KAAQH,EAAgBK,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,MACjIH,EAAgBE,IAAI5D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,IACpD7D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAM7B,SAAWF,EAC3CsB,EAAU7C,KAAKX,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,QAExB,MAAjB/B,EAAQgC,OAAkB9E,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,KAAQH,EAAgBK,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,MACpIH,EAAgBE,IAAI5D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,IACrD7D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAO9B,SAAWF,EAC5CsB,EAAU7C,KAAKX,EAAKkC,EAAQzC,KAAKyC,EAAQgC,UAKzD,MAAO,CAACX,EAAa,IETWY,CAAInE,EAAKjB,KAAKC,MAAMC,QACxC,MAEA,IAAK,MAAQF,KAAKC,MAAMqE,eACxBtE,KAAK4D,SAAS,CAACM,kBAAoB,QACnClE,KAAKC,MAAMsE,SFO3B,SAAatD,EAAMf,GAIf,IAHA,IAAIsE,EAAc,GACdC,EAAY,CAACvE,GACbG,EAAU,IAAIqE,IACXD,EAAUxC,QAAQ,CACrB,IAAIkB,EAAUsB,EAAUY,MACxB,GAAIlC,EAAQhD,IACR,MAAO,CAACqE,EAAatB,EAAcjC,EAAMkC,MAEpCA,EAAQ/C,MAAS+C,EAAQjD,OAASiD,EAAQ/C,QACtC+C,EAAQjD,OAAUG,EAAQ2E,IAAI7B,EAAQ2B,KACvCN,EAAY5C,KAAK,CAACuB,EAAQzC,IAAKyC,EAAQxC,MAE3CN,EAAQwE,IAAI1B,EAAQ2B,IACD,MAAf3B,EAAQ4B,KAAgB1E,EAAQ2E,IAAI/D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,MACnE7D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAK0C,SAAWF,EAC1CsB,EAAU7C,KAAKX,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,OAEvB,MAAlBwC,EAAQ8B,QAAmB5E,EAAQ2E,IAAI/D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,MACzE7D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAK0C,SAAWF,EAC7CsB,EAAU7C,KAAKX,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,OAE5B,MAAhBwC,EAAQ+B,MAAiB7E,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,MACrE7D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAM7B,SAAWF,EAC3CsB,EAAU7C,KAAKX,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,QAExB,MAAjB/B,EAAQgC,OAAkB9E,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,MACvE7D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAO9B,SAAWF,EAC5CsB,EAAU7C,KAAKX,EAAKkC,EAAQzC,KAAKyC,EAAQgC,UAKzD,MAAO,CAACX,EAAa,IExCWc,CAAIrE,EAAKjB,KAAKC,MAAMC,QACxC,MAEA,IAAK,MAAQF,KAAKC,MAAMqE,eACxBtE,KAAK4D,SAAS,CAACM,kBAAoB,wBACnClE,KAAKC,MAAMsE,SFuC3B,SAA6BtD,EAAMf,EAAOC,GACtCoF,QAAQC,IAAItF,GAOZ,IANA,IAAIsE,EAAc,GACdiB,EAAiB,CAACvF,GAClBwF,EAAe,CAACvF,GAChBE,EAAU,IAAIqE,IACdiB,EAAa,IAAIjB,IACjBkB,EAAW,IAAIlB,IACZe,EAAexD,QAAUyD,EAAazD,QAAQ,CACjD,IAAIkB,EAAUsC,EAAeb,QAC7B,GAAIzB,EAAQhD,IACR,MAAO,CAACqE,EAAatB,EAAcjC,EAAMkC,IAEzC,IAAKA,EAAQ/C,MAAS+C,EAAQjD,OAASiD,EAAQ/C,KAAO,CAKlD,GAJAC,EAAQwE,IAAI1B,EAAQ2B,IACpBa,EAAWd,IAAI1B,EAAQ2B,IACvBN,EAAY5C,KAAK,CAACuB,EAAQzC,IAAKyC,EAAQxC,MAEpB,MAAfwC,EAAQ4B,KAAgB1E,EAAQ2E,IAAI/D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,KAAQa,EAAWX,IAAI/D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,KAItH,GAAIzE,EAAQ2E,IAAI/D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,IAElD,MAAO,CAACN,EADKtB,EAAcjC,EAAMkC,GACL0C,OAAO3C,EAAcjC,EAAMA,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,aALjFM,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAK0C,SAAWF,EAC1CwC,EAAWd,IAAI5D,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,KAAKmE,IAC9CW,EAAe7D,KAAKX,EAAKkC,EAAQ4B,KAAK5B,EAAQxC,MAKlD,GAAsB,MAAlBwC,EAAQ8B,QAAmB5E,EAAQ2E,IAAI/D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,KAAQa,EAAWX,IAAI/D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,KAI/H,GAAIzE,EAAQ2E,IAAI/D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,IAErD,MAAO,CAACN,EADKtB,EAAcjC,EAAMkC,GACL0C,OAAO3C,EAAcjC,EAAMA,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,aALpFgF,EAAWd,IAAI5D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAKmE,IACjD7D,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,KAAK0C,SAAWF,EAC7CsC,EAAe7D,KAAKX,EAAKkC,EAAQ8B,QAAQ9B,EAAQxC,MAKrD,GAAoB,MAAhBwC,EAAQ+B,MAAiB7E,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,KAAQa,EAAWX,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,KAIzH,GAAIzE,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,OAE7C,MAAO,CAACV,EADKtB,EAAcjC,EAAMkC,GACL0C,OAAO3C,EAAcjC,EAAMA,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,cALjFS,EAAWd,IAAI5D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAMJ,IAC/C7D,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,MAAM7B,SAAWF,EAC3CsC,EAAe7D,KAAKX,EAAKkC,EAAQzC,KAAKyC,EAAQ+B,OAKlD,GAAqB,MAAjB/B,EAAQgC,OAAkB9E,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,KAAQa,EAAWX,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,KAI5H,GAAIzE,EAAQ2E,IAAI/D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,QAE7C,MAAO,CAACX,EADKtB,EAAcjC,EAAMkC,GACL0C,OAAO3C,EAAcjC,EAAMA,EAAKkC,EAAQzC,KAAKyC,EAAQgC,eALjFQ,EAAWd,IAAI5D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAOL,IAChD7D,EAAKkC,EAAQzC,KAAKyC,EAAQgC,OAAO9B,SAAWF,EAC5CsC,EAAe7D,KAAKX,EAAKkC,EAAQzC,KAAKyC,EAAQgC,QAO1D,IAAIW,EAAUJ,EAAad,QAE3B,GADAW,QAAQC,IAAIM,GACRA,EAAQ5F,MACR,MAAO,CAACsE,EAAatB,EAAcjC,EAAM6E,IAEzC,IAAKA,EAAQ1F,MAAS0F,EAAQ5F,OAAS4F,EAAQ1F,KAAO,CAIlD,GAHAC,EAAQwE,IAAIiB,EAAQhB,IACpBc,EAASf,IAAIiB,EAAQhB,IACrBN,EAAY5C,KAAK,CAACkE,EAAQpF,IAAKoF,EAAQnF,MACpB,MAAfmF,EAAQf,KAAgB1E,EAAQ2E,IAAI/D,EAAK6E,EAAQf,KAAKe,EAAQnF,KAAKmE,KAAQc,EAASZ,IAAI/D,EAAK6E,EAAQf,KAAKe,EAAQnF,KAAKmE,KAIpH,GAAIzE,EAAQ2E,IAAI/D,EAAK6E,EAAQf,KAAKe,EAAQnF,KAAKmE,IAElD,MAAO,CAACN,EADKtB,EAAcjC,EAAM6E,GACLD,OAAO3C,EAAcjC,EAAMA,EAAK6E,EAAQf,KAAKe,EAAQnF,aALjFM,EAAK6E,EAAQf,KAAKe,EAAQnF,KAAK0C,SAAWyC,EAC1CF,EAASf,IAAI5D,EAAK6E,EAAQf,KAAKe,EAAQnF,KAAKmE,IAC5CY,EAAa9D,KAAKX,EAAK6E,EAAQf,KAAKe,EAAQnF,MAKhD,GAAsB,MAAlBmF,EAAQb,QAAmB5E,EAAQ2E,IAAI/D,EAAK6E,EAAQb,QAAQa,EAAQnF,KAAKmE,KAAQc,EAASZ,IAAI/D,EAAK6E,EAAQb,QAAQa,EAAQnF,KAAKmE,KAI7H,GAAIzE,EAAQ2E,IAAI/D,EAAK6E,EAAQb,QAAQa,EAAQnF,KAAKmE,IAErD,MAAO,CAACN,EADKtB,EAAcjC,EAAM6E,GACLD,OAAO3C,EAAcjC,EAAMA,EAAK6E,EAAQb,QAAQa,EAAQnF,aALpFiF,EAASf,IAAI5D,EAAK6E,EAAQb,QAAQa,EAAQnF,KAAKmE,IAC/C7D,EAAK6E,EAAQb,QAAQa,EAAQnF,KAAK0C,SAAWyC,EAC7CJ,EAAa9D,KAAKX,EAAK6E,EAAQb,QAAQa,EAAQnF,MAKnD,GAAoB,MAAhBmF,EAAQZ,MAAiB7E,EAAQ2E,IAAI/D,EAAK6E,EAAQpF,KAAKoF,EAAQZ,MAAMJ,KAAQc,EAASZ,IAAI/D,EAAK6E,EAAQpF,KAAKoF,EAAQZ,MAAMJ,KAIvH,GAAIzE,EAAQ2E,IAAI/D,EAAK6E,EAAQpF,KAAKoF,EAAQZ,OAE7C,MAAO,CAACV,EADKtB,EAAcjC,EAAM6E,GACLD,OAAO3C,EAAcjC,EAAMA,EAAK6E,EAAQpF,KAAKoF,EAAQZ,cALjFU,EAASf,IAAI5D,EAAK6E,EAAQpF,KAAKoF,EAAQZ,MAAMJ,IAC7C7D,EAAK6E,EAAQpF,KAAKoF,EAAQZ,MAAM7B,SAAWyC,EAC3CJ,EAAa9D,KAAKX,EAAK6E,EAAQpF,KAAKoF,EAAQZ,OAKhD,GAAqB,MAAjBY,EAAQX,OAAkB9E,EAAQ2E,IAAI/D,EAAK6E,EAAQpF,KAAKoF,EAAQX,OAAOL,KAAQc,EAASZ,IAAI/D,EAAK6E,EAAQpF,KAAKoF,EAAQX,OAAOL,KAI1H,GAAIzE,EAAQ2E,IAAI/D,EAAK6E,EAAQpF,KAAKoF,EAAQX,QAE7C,MAAO,CAACX,EADKtB,EAAcjC,EAAM6E,GACLD,OAAO3C,EAAcjC,EAAMA,EAAK6E,EAAQpF,KAAKoF,EAAQX,eALjFS,EAASf,IAAI5D,EAAK6E,EAAQpF,KAAKoF,EAAQX,OAAOL,IAC9C7D,EAAK6E,EAAQpF,KAAKoF,EAAQX,OAAO9B,SAAWyC,EAC5CJ,EAAa9D,KAAKX,EAAK6E,EAAQpF,KAAKoF,EAAQX,SAS5D,MAAO,CAACX,EAAa,IExIWuB,CAAoB9E,EAAKjB,KAAKC,MAAMC,MAAMF,KAAKC,MAAME,S,2BAMrF,SAAciE,EAAKnD,GAEf,GADAjB,KAAKgG,0BACDhG,KAAKC,MAAMoE,OACX,OAAOD,GACH,IAAK,gBAAkBpE,KAAKC,MAAMgG,eAClCjG,KAAKC,MAAMiG,YACXlG,KAAKC,MAAMkG,WAAWnF,EAAsBC,EAAKjB,KAAKC,MAAMC,MAAMF,KAAKC,MAAME,IAAIH,KAAKC,MAAMmB,OAAOpB,KAAKC,MAAMoB,W,oBAK1H,WAAS,IAAD,OACA+E,EAAQC,OAAOC,OAAO,GAAGtG,KAAKC,MAAMkD,SAKxC,OAHe,IADDnD,KAAKC,MAAMsG,QAErBvG,KAAKwG,gBAAgBxG,KAAKmE,MAAMD,kBAAkBkC,GAGlD,sBAAK5F,UAAY,SAAjB,UACI,yBAAQiG,SAAUzG,KAAK0D,iBAAkBK,MAAQ/D,KAAKmE,MAAMN,KAA5D,UACI,wBAAQE,MAAM,sBAAd,iCACA,wBAAQA,MAAM,gBAAd,0CAEJ,wBAAQ2C,QAAS,kBAAM,EAAKC,cAAc,EAAKxC,MAAMN,KAAKuC,IAA1D,SAAmEpG,KAAKmE,MAAMN,OAC9E,yBAAQpD,GAAG,aAAagG,SAAUzG,KAAKgE,sBAAuBD,MAAQ/D,KAAKmE,MAAMF,UAAjF,UACI,wBAAQF,MAAM,MAAd,kCACA,wBAAQA,MAAO,MAAf,gCACA,wBAAQA,MAAQ,MAAhB,oCAEJ,wBAAQ2C,QAAS,kBAAM,EAAKF,gBAAgB,EAAKrC,MAAMF,UAAUmC,IAAjE,SAA0EpG,KAAKmE,MAAMF,YAErF,wBAAQyC,QAAU,WAAO,EAAKzG,MAAMiG,YAAa,EAAKF,0BAAtD,yBACA,wBAAQU,QAAS,WAAO,EAAKzG,MAAMqE,eAAgB,EAAK0B,0BAAxD,+B,GAzEoBjF,aDO9B6F,EAAQ,SAAAC,GAAE,OAAI,IAAIC,SAAQ,SAAAC,GAAO,OAAIC,WAAWD,EAASF,OAG1CI,E,kDACnB,aAAe,IAAD,8BACZ,gBAgMFC,mBAAqB,SAACC,EAAMC,EAAMC,GAChC,IAAI,EAAKlD,MAAME,OAAO,CACpB,IAAMpD,EAAO,EAAKkD,MAAMmD,MACpBrG,EAAKkG,GAAMC,GAAMlH,OAAUe,EAAKkG,GAAMC,GAAMjH,IAI5C,EAAKyD,SAAS,CACZ2D,cAAe,EACfC,YAAcvG,EAAKkG,GAAMC,MAL7BnG,EAAKkG,GAAMC,GAAMhH,MAAQa,EAAKkG,GAAMC,GAAMhH,KAC1C,EAAKqH,YAAYN,EAAMC,EAAMnG,EAAKkG,GAAMC,OAtMhC,EAiNdM,mBAAqB,SAACP,EAAMC,GAC1B,IAAI,EAAKjD,MAAME,OAAO,CACpB,IAAMpD,EAAO,EAAKkD,MAAMmD,MACxB,IAAK,EAAKnD,MAAMoD,cAAgB,EAAKpD,MAAMqD,cAAgBvG,EAAKkG,GAAMC,GACpE,OACC,EAAKjD,MAAMqD,YAAYtH,OAAS,EAAKiE,MAAMqD,YAAYrH,KAAOc,EAAKkG,GAAMC,IAAS,EAAKjD,MAAMqD,YAC1FvG,EAAKkG,GAAMC,GAAMjH,KAAQc,EAAKkG,GAAMC,GAAMlH,QACzC,EAAKiE,MAAMqD,YAAYtH,QAAUe,EAAKkG,GAAMC,GAAMjH,KACnDc,EAAKkG,GAAMC,GAAMlH,OAAQ,EACzBe,EAAK,EAAKkD,MAAMqD,YAAY9G,KAAK,EAAKyD,MAAMqD,YAAY7G,KAAKT,OAAQ,EACrE,EAAK0D,SAAS,CACZ4D,YAAcvG,EAAKkG,GAAMC,GACzBlG,UAAYD,EAAKkG,GAAMC,GACvBO,SAAU,KAEL,EAAKxD,MAAMqD,YAAYrH,MAAQc,EAAKkG,GAAMC,GAAMlH,QACvDe,EAAKkG,GAAMC,GAAMjH,KAAM,EACvBc,EAAK,EAAKkD,MAAMqD,YAAY9G,KAAK,EAAKyD,MAAMqD,YAAY7G,KAAKR,KAAM,EACnE,EAAKyD,SAAS,CACZ4D,YAAcvG,EAAKkG,GAAMC,GACzBtB,QAAU7E,EAAKkG,GAAMC,GACrBO,SAAU,MAIR1G,EAAKkG,GAAMC,GAAMlH,OAAUe,EAAKkG,GAAMC,GAAMjH,MACpDc,EAAKkG,GAAMC,GAAMhH,MAAQa,EAAKkG,GAAMC,GAAMhH,KAC1C,EAAKqH,YAAYN,EAAMC,EAAMnG,EAAKkG,GAAMC,OA5OhC,EAkPdQ,gBAAkB,SAACP,GACb,EAAKlD,MAAME,QACb,EAAKT,SAAS,CACZ2D,cAAc,EACdI,SAAU,KApPd,EAAKxD,MAAQ,CACXmD,MAAO,GACPC,cAAc,EACdC,YAAa,CACX9G,KAAM,EACNC,KAAM,EACNT,OAAO,EACPC,KAAK,EACLkD,SAAU,KACV0B,IAAK,KACLE,OAAQ,KACRC,KAAM,KACNC,MAAO,KACP/E,MAAM,EACN0E,IAAK,GAEPT,QAAS,EACTJ,UAAY,KACZ/C,UAAY,CACVR,IAAK,EACLC,IAAK,EACLT,OAAO,EACPC,KAAK,EACLkD,SAAU,KACV0B,IAAK,KACLE,OAAQ,EACRC,KAAM,KACNC,MAAO,EACP/E,MAAM,EACN0E,GAAG,GAELgB,QAAU,CACRpF,IAAK6C,EAAa,EAClB5C,IAAK6C,EAAc,EACnBtD,OAAO,EACPC,KAAK,EACLkD,SAAU,KACV0B,IAAK,GACLE,OAAQ,KACRC,KAAM,GACNC,MAAO,KACP/E,MAAM,EACN0E,GAAItB,EAAcD,EAAa,GAEjCoE,SAAU,GA9CA,E,qDAkDd,WAuSF,IAAiBtG,EAAMD,EAANC,EAtSLwG,OAAOC,WAsSI1G,EAtSOyG,OAAOE,YAuSnCvE,EAAcf,KAAKC,MAAMtB,EAAS,IAClCmC,EAAad,KAAKC,MAAMrB,EAAQ,IAvS9B,IAAM2G,EAAM/G,IACZjB,KAAK4D,SAAS,CAAE0D,MAAQU,M,iCAG1B,SAAoBC,EAAYC,GAC9BC,SAASC,eAAT,cAA+BH,EAAYvH,IAA3C,gBAAsDuH,EAAYtH,MAAOH,UAAY0H,I,kCAGvF,WACE,IAAM7D,EAASrE,KAAKmE,MAAME,OAC1BrE,KAAK4D,SAAS,CACZS,QAAUA,M,uBAId,WAEE,IADA,IAAMpD,EAAOjB,KAAKmE,MAAMmD,MAChB3F,EAAI,EAAGA,EAAI6B,EAAa7B,IAC9B,IAAI,IAAI0G,EAAI,EAAGA,EAAI9E,EAAY8E,IACzBpH,EAAKU,GAAG0G,GAAGnI,OAAUe,EAAKU,GAAG0G,GAAGlI,IAOlCc,EAAKU,GAAG0G,GAAGjI,MAAO,EAClBa,EAAKU,GAAG0G,GAAGhI,SAAU,EACrBY,EAAKU,GAAG0G,GAAG9H,MAAO,EAClBU,EAAKU,GAAG0G,GAAG/H,iBAAkB,EAInCN,KAAK4D,SAAS,CAAC0D,MAAQrG,M,2BAGzB,SAAcqH,GACZtI,KAAK4D,SAAS,CACZ+D,QAAUW,M,0BAId,WAEE,IADA,IAAMrH,EAAOjB,KAAKmE,MAAMmD,MAChB3F,EAAI,EAAGA,EAAI6B,EAAa7B,IAC9B,IAAI,IAAI0G,EAAI,EAAGA,EAAI9E,EAAY8E,IAC7BpH,EAAKU,GAAG0G,GAAGhF,SAAW,KAClBpC,EAAKU,GAAG0G,GAAGnI,OAAUe,EAAKU,GAAG0G,GAAGlI,KAAQc,EAAKU,GAAG0G,GAAGjI,KAMrDa,EAAKU,GAAG0G,GAAGhI,SAAU,EACrBY,EAAKU,GAAG0G,GAAG9H,MAAO,EAClBU,EAAKU,GAAG0G,GAAG/H,iBAAkB,EAInCN,KAAK4D,SAAS,CAAC0D,MAAOrG,M,4BAGxB,SAAesH,GACbvI,KAAKwI,aAAaD,K,6BAGpB,SAAgBE,GACXzI,KAAKmE,MAAMwD,QACZ3H,KAAK0I,aAAaD,EAAS,GAAGA,EAAS,IAEvCzI,KAAK2I,YAAYF,EAAS,GAAGA,EAAS,M,0BAI1C,SAAaG,EAAaC,GACxB,IADsC,EAClC5H,EAAOjB,KAAKmE,MAAMmD,MADgB,cAErBsB,GAFqB,IAEtC,IAAI,EAAJ,qBAA8B,CAAC,IAAvBE,EAAsB,QACxB7H,EAAK6H,EAAM,IAAIA,EAAM,IAAI5I,OAAUe,EAAK6H,EAAM,IAAIA,EAAM,IAAI3I,MAC9Dc,EAAK6H,EAAM,IAAIA,EAAM,IAAIxI,iBAAkB,IAJT,kDAOrBuI,GAPqB,IAOtC,IAAI,EAAJ,qBAA+B,CAAC,IAAxBC,EAAuB,QAC7B7H,EAAK6H,EAAM,IAAIA,EAAM,IAAIzI,SAAU,EACnCY,EAAK6H,EAAM,IAAIA,EAAM,IAAIxI,iBAAkB,EAC3CW,EAAK6H,EAAM,IAAIA,EAAM,IAAIvI,MAAO,GAVI,8BAYtCP,KAAK4D,SAAS,CAAC0D,MAAQrG,IACvBjB,KAAK+I,cAAc,W,gEAGrB,WAAkBH,EAAaC,GAA/B,2BAAAjG,EAAA,sDACE5C,KAAKgJ,uBACD/H,EAAOjB,KAAKmE,MAAMmD,MAFxB,cAGmBsB,GAHnB,4DAGUE,EAHV,QAIQ7H,EAAK6H,EAAM,IAAIA,EAAM,IAAI5I,OAAUe,EAAK6H,EAAM,IAAIA,EAAM,IAAI3I,IAJpE,wBAKMc,EAAK6H,EAAM,IAAIA,EAAM,IAAIzI,SAAU,EACnCY,EAAK6H,EAAM,IAAIA,EAAM,IAAIxI,iBAAkB,EAC3CW,EAAK6H,EAAM,IAAIA,EAAM,IAAIvI,MAAO,EAChCP,KAAKiJ,oBAAoBhI,EAAK6H,EAAM,IAAIA,EAAM,IAAI,qBARxD,UASYlC,EAAM,IATlB,6JAYmBiC,GAZnB,kEAYUC,EAZV,QAaI7H,EAAK6H,EAAM,IAAIA,EAAM,IAAIzI,SAAU,EACnCL,KAAKiJ,oBAAoBhI,EAAK6H,EAAM,IAAIA,EAAM,IAAI,kBAdtD,UAeUlC,EAAM,IAfhB,iJAiBE5G,KAAKgJ,uBAjBP,8E,0HAoBA,WAAmBT,GAAnB,qBAAA3F,EAAA,sDACE5C,KAAKgJ,uBACD/H,EAAOjB,KAAKmE,MAAMmD,MAFxB,cAGmBiB,GAHnB,gEAGUO,EAHV,QAII7H,EAAK6H,EAAM,IAAIA,EAAM,IAAI1I,MAAO,EAChCJ,KAAKiJ,oBAAoBhI,EAAK6H,EAAM,IAAIA,EAAM,IAAI,kBALtD,UAMUlC,EAAM,IANhB,+IAQE5G,KAAKgJ,uBARP,gE,gFAWA,SAAY7B,EAAMC,EAAM8B,GACtBlJ,KAAK4D,SACHuF,IAAOnJ,KAAKmE,MAAO,CACjBmD,MAAM,eACHH,EADE,eAEAC,EAAO,CACNgC,KAAMF,KAIZ3B,aAAc,CACZ6B,MAAM,GAER5B,YAAa,CACX4B,KAAMF,Q,oBAgEd,WAAU,IAAD,SAGDG,GADOrJ,KAAKmE,MAAMmD,MACFtH,KAAKmE,MAAMmD,MAAMgC,KAAI,SAACnC,EAAMoC,GAChD,OACE,oBAAI/I,UAAS,mBAAc+I,GAA3B,SACGpC,EAAKmC,KAAI,SAAClC,EAAMoC,GACf,OACE,cAAC,EAAD,CACE/I,GAAI+I,EACJ9I,IAAK0G,EAAK1G,IACVC,IAAKyG,EAAKzG,IACVP,KAAMgH,EAAKhH,KACXF,MAAOkH,EAAKlH,MACZC,IAAOiH,EAAKjH,IACZE,QAAW+G,EAAK/G,QAChBC,gBAAmB8G,EAAK9G,gBACxBC,KAAQ6G,EAAK7G,KACbK,YAAa,SAACF,EAAKC,GAAN,OAAc,EAAKuG,mBAAmBxG,EAAIC,IACvDE,aAAc,SAACH,EAAKC,GAAN,OAAc,EAAK+G,mBAAmBhH,EAAKC,IACzDG,UAAW,kBAAM,EAAK8G,8BAOlC,OACE,gCACE,cAAC,GAAD,GACErB,OAAU,SAACkD,EAAOvB,GAAR,OAAgB,EAAKe,oBAAoBQ,EAAOvB,IAC1D/E,QAAWnD,KAAKmE,MAAMmD,MACtBjD,OAAUrE,KAAKmE,MAAME,OACrBnE,MAASF,KAAKmE,MAAMjD,UACpBf,IAAOH,KAAKmE,MAAM2B,QAClBG,aAAgB,kBAAM,EAAK+C,wBAC3B7C,WAAc,SAACuD,GAAD,OAAS,EAAKC,eAAeD,IAC3CxD,UAAa,kBAAM,EAAKA,aACxB5B,aAAgB,kBAAM,EAAKA,gBAC3BC,SAAY,SAAChE,EAAKmB,GAAN,OAAiB,EAAKkI,gBAAgBrJ,EAAKmB,IACvDN,OAAUoC,EACVnC,MAASkC,GAZX,uBAaYvD,KAAKmE,MAAMwD,SAbvB,+BAcmB,SAACW,GAAD,OAAe,EAAKS,cAAcT,MAdrD,IAgBA,sBAAK9H,UAAU,SAASqJ,aAAa,KAArC,UA5CY,GA8CV,uBAAOC,YAAY,IAAnB,SACE,gCACGT,gB,GA7S8BtI,aAsTvCE,EAAO,WAGX,IAFA,IAAI8I,EAAU,EACRC,EAAW,GACRrI,EAAI,EAAGA,EAAI6B,EAAa7B,IAAK,CAEpC,IADA,IAAMsI,EAAW,GACR5B,EAAI,EAAGA,EAAI9E,EAAY8E,IAC9B4B,EAASrI,KAAKsI,EAAWvI,EAAG0G,EAAE0B,IAC9BA,IAEFC,EAASpI,KAAKqI,GAIhB,OAFAD,EAAS,GAAG,GAAG9J,OAAQ,EACvB8J,EAASA,EAAS/H,OAAS,GAAG+H,EAAS,GAAG/H,OAAS,GAAG9B,KAAM,EACrD6J,GAGHE,EAAa,SAACvI,EAAG0G,EAAG0B,GAiBxB,MAhBgB,CACdrJ,IAAKiB,EACLhB,IAAK0H,EACLnI,OAAO,EACPC,KAAK,EACLkD,SAAU,KACV0B,IAAW,IAANpD,EAAU,KAAOA,EAAI,EAC1BsD,OAAQtD,IAAM6B,EAAc,EAAI,KAAO7B,EAAI,EAC3CuD,KAAY,IAANmD,EAAU,KAAOA,EAAI,EAC3BlD,MAAOkD,IAAM9E,EAAa,EAAI,KAAO8E,EAAI,EACzCjI,MAAM,EACNC,SAAU,EACVyE,GAAIiF,EACJxJ,MAAM,EACND,iBAAkB,I,IExVP6J,E,4JAPX,WACI,OACI,cAAC,EAAD,Q,GAHMC,IAAMrJ,WCCxBsJ,IAASC,OACP,cAAC,EAAD,IACAnC,SAASC,eAAe,W","file":"static/js/main.249aafab.chunk.js","sourcesContent":["import React , {Component} from \"react\"\r\nimport './Node.css';\r\n\r\nclass Nodes extends Component{\r\n\r\n    render(){\r\n        const nodeClass = this.props.start ? 'Node node-start' :  this.props.end ? 'Node node-end' : this.props.wall ? 'Node node-wall' : this.props.visited ? 'Node node-visited' : this.props.visitedRealTime ? 'Node node-realtime' : this.props.path ? 'Node node-realtimePath' : 'Node'\r\n        return(\r\n            <td className = {nodeClass}\r\n            id = {`row-${this.props.row}-col-${this.props.col}`}\r\n            onMouseDown = {() => this.props.onMouseDown(this.props.row,this.props.col)}\r\n            onMouseEnter = {() => this.props.onMouseEnter(this.props.row,this.props.col)}\r\n            onMouseUp = {() => this.props.onMouseUp()}\r\n            >\r\n            </td>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Nodes;","export default function recursiveDivisionMaze(grid, startNode, finishNode, height, width) {\r\n    if (!startNode || !finishNode || startNode === finishNode) {\r\n        return false;\r\n    }\r\n    let vertical = range(width);\r\n    let horizontal = range(height);\r\n    let walls = [];\r\n    getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, walls);\r\n    return walls;\r\n}\r\n\r\nfunction range(len) {\r\n    let result = [];\r\n    for (let i = 0; i < len; i++) {\r\n        result.push(i);\r\n    }\r\n    return result;\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nfunction getRecursiveWalls(vertical, horizontal, grid, startNode, finishNode, walls) {\r\n    if (vertical.length < 2 || horizontal.length < 2) {\r\n        return;\r\n    }\r\n    let dir;\r\n    let num;\r\n    if (vertical.length > horizontal.length) {\r\n        dir = 0;\r\n        num = generateOddRandomNumber(vertical);\r\n    }\r\n    if (vertical.length <= horizontal.length) {\r\n        dir = 1;\r\n        num = generateOddRandomNumber(horizontal);\r\n    }\r\n\r\n    if (dir === 0) {\r\n        addWall(grid, dir, num, vertical, horizontal, startNode, finishNode, walls);\r\n        getRecursiveWalls(\r\n            vertical.slice(0, vertical.indexOf(num)),\r\n            horizontal,\r\n            grid,\r\n            startNode,\r\n            finishNode,\r\n            walls,\r\n        );\r\n        getRecursiveWalls(\r\n            vertical.slice(vertical.indexOf(num) + 1),\r\n            horizontal,\r\n            grid,\r\n            startNode,\r\n            finishNode,\r\n            walls\r\n        );\r\n    } else {\r\n        addWall(grid, dir, num, vertical, horizontal, startNode, finishNode, walls);\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(0, horizontal.indexOf(num)),\r\n            grid,\r\n            startNode,\r\n            finishNode,\r\n            walls\r\n        );\r\n        getRecursiveWalls(\r\n            vertical,\r\n            horizontal.slice(horizontal.indexOf(num) + 1),\r\n            grid,\r\n            startNode,\r\n            finishNode,\r\n            walls\r\n        );\r\n    }\r\n}\r\n\r\nfunction generateOddRandomNumber(array) {\r\n    let max = array.length - 1;\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 === 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return array[randomNum];\r\n}\r\n\r\n//dir === 0 => Horizontal\r\n//dir === 1 => Vertical\r\n\r\nasync function addWall(grid, dir, num, vertical, horizontal, startNode, finishNode, walls) {\r\n    let isStartFinish = false;\r\n    let tempWalls = [];\r\n    if (dir === 0) {\r\n        if (horizontal.length === 2) return;\r\n        for (let temp of horizontal) {\r\n            if (\r\n                (temp === startNode.row && num === startNode.col) ||\r\n                (temp === finishNode.row && num === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([temp, num]);\r\n        }\r\n    } else {\r\n        if (vertical.length === 2) return;\r\n        for (let temp of vertical) {\r\n            if (\r\n                (num === startNode.row && temp === startNode.col) ||\r\n                (num === finishNode.row && temp === finishNode.col)\r\n            ) {\r\n                isStartFinish = true;\r\n                continue;\r\n            }\r\n            tempWalls.push([num, temp]);\r\n        }\r\n    }\r\n    if (!isStartFinish) {\r\n        tempWalls.splice(generateRandomNumber(tempWalls.length), 1);\r\n    }\r\n    for (let wall of tempWalls) {\r\n        walls.push(wall)\r\n    }\r\n}\r\n\r\nfunction generateRandomNumber(max) {\r\n    let randomNum =\r\n        Math.floor(Math.random() * (max / 2)) +\r\n        Math.floor(Math.random() * (max / 2));\r\n    if (randomNum % 2 !== 0) {\r\n        if (randomNum === max) {\r\n            randomNum -= 1;\r\n        } else {\r\n            randomNum += 1;\r\n        }\r\n    }\r\n    return randomNum;\r\n}","function bfs(grid, start) {\r\n    let visitedPath = []\r\n    let neighbors = [start]\r\n    let visited = new Set()\r\n    let cacheNeighbours = new Set()\r\n    while (neighbors.length) {\r\n        let current = neighbors.shift()\r\n        if (current.end) {\r\n            return [visitedPath, getResultPath(grid, current)]\r\n        } else {\r\n            if (!current.wall || (current.start && current.wall)) {\r\n                visited.add(current.no)\r\n                cacheNeighbours.add(current.no)\r\n                visitedPath.push([current.row, current.col])\r\n\r\n                if (current.top != null && !visited.has(grid[current.top][current.col].no) && !cacheNeighbours.has(grid[current.top][current.col].no)) {\r\n                    grid[current.top][current.col].previous = current\r\n                    cacheNeighbours.add(grid[current.top][current.col].no)\r\n                    neighbors.push(grid[current.top][current.col])\r\n                }\r\n                if (current.bottom != null && !visited.has(grid[current.bottom][current.col].no) && !cacheNeighbours.has(grid[current.bottom][current.col].no)) {\r\n                    cacheNeighbours.add(grid[current.bottom][current.col].no)\r\n                    grid[current.bottom][current.col].previous = current\r\n                    neighbors.push(grid[current.bottom][current.col])\r\n                }\r\n                if (current.left != null && !visited.has(grid[current.row][current.left].no) && !cacheNeighbours.has(grid[current.row][current.left].no)) {\r\n                    cacheNeighbours.add(grid[current.row][current.left].no)\r\n                    grid[current.row][current.left].previous = current\r\n                    neighbors.push(grid[current.row][current.left])\r\n                }\r\n                if (current.right != null && !visited.has(grid[current.row][current.right].no) && !cacheNeighbours.has(grid[current.row][current.right].no)) {\r\n                    cacheNeighbours.add(grid[current.row][current.right].no)\r\n                    grid[current.row][current.right].previous = current\r\n                    neighbors.push(grid[current.row][current.right])\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return [visitedPath, []]\r\n}\r\n\r\nfunction dfs(grid, start) {\r\n    let visitedPath = []\r\n    let neighbors = [start]\r\n    let visited = new Set()\r\n    while (neighbors.length) {\r\n        let current = neighbors.pop()\r\n        if (current.end) {\r\n            return [visitedPath, getResultPath(grid, current)]\r\n        } else {\r\n            if (!current.wall || (current.start && current.wall)) {\r\n                if (!current.start && !visited.has(current.no)) {\r\n                    visitedPath.push([current.row, current.col])\r\n                }\r\n                visited.add(current.no)\r\n                if (current.top != null && !visited.has(grid[current.top][current.col].no)) {\r\n                    grid[current.top][current.col].previous = current\r\n                    neighbors.push(grid[current.top][current.col])\r\n                }\r\n                if (current.bottom != null && !visited.has(grid[current.bottom][current.col].no)) {\r\n                    grid[current.bottom][current.col].previous = current\r\n                    neighbors.push(grid[current.bottom][current.col])\r\n                }\r\n                if (current.left != null && !visited.has(grid[current.row][current.left].no)) {\r\n                    grid[current.row][current.left].previous = current\r\n                    neighbors.push(grid[current.row][current.left])\r\n                }\r\n                if (current.right != null && !visited.has(grid[current.row][current.right].no)) {\r\n                    grid[current.row][current.right].previous = current\r\n                    neighbors.push(grid[current.row][current.right])\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return [visitedPath, []]\r\n}\r\n\r\n\r\nfunction bidirectionalSearch(grid, start, end) {\r\n    console.log(start)\r\n    let visitedPath = []\r\n    let startNeighbors = [start]\r\n    let endNeighbors = [end]\r\n    let visited = new Set()\r\n    let startCache = new Set()\r\n    let endCache = new Set()\r\n    while (startNeighbors.length && endNeighbors.length) {\r\n        let current = startNeighbors.shift()\r\n        if (current.end) {\r\n            return [visitedPath, getResultPath(grid, current)]\r\n        } else {\r\n            if (!current.wall || (current.start && current.wall)) {\r\n                visited.add(current.no)\r\n                startCache.add(current.no)\r\n                visitedPath.push([current.row, current.col])\r\n\r\n                if (current.top != null && !visited.has(grid[current.top][current.col].no) && !startCache.has(grid[current.top][current.col].no)) {\r\n                    grid[current.top][current.col].previous = current\r\n                    startCache.add(grid[current.top][current.col].no)\r\n                    startNeighbors.push(grid[current.top][current.col])\r\n                } else if (visited.has(grid[current.top][current.col].no)) {\r\n                    let result = getResultPath(grid, current)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[current.top][current.col]))]\r\n                }\r\n                if (current.bottom != null && !visited.has(grid[current.bottom][current.col].no) && !startCache.has(grid[current.bottom][current.col].no)) {\r\n                    startCache.add(grid[current.bottom][current.col].no)\r\n                    grid[current.bottom][current.col].previous = current\r\n                    startNeighbors.push(grid[current.bottom][current.col])\r\n                } else if (visited.has(grid[current.bottom][current.col].no)) {\r\n                    let result = getResultPath(grid, current)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[current.bottom][current.col]))]\r\n                }\r\n                if (current.left != null && !visited.has(grid[current.row][current.left].no) && !startCache.has(grid[current.row][current.left].no)) {\r\n                    startCache.add(grid[current.row][current.left].no)\r\n                    grid[current.row][current.left].previous = current\r\n                    startNeighbors.push(grid[current.row][current.left])\r\n                } else if (visited.has(grid[current.row][current.left])) {\r\n                    let result = getResultPath(grid, current)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[current.row][current.left]))]\r\n                }\r\n                if (current.right != null && !visited.has(grid[current.row][current.right].no) && !startCache.has(grid[current.row][current.right].no)) {\r\n                    startCache.add(grid[current.row][current.right].no)\r\n                    grid[current.row][current.right].previous = current\r\n                    startNeighbors.push(grid[current.row][current.right])\r\n                } else if (visited.has(grid[current.row][current.right])) {\r\n                    let result = getResultPath(grid, current)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[current.row][current.right]))]\r\n                }\r\n            }\r\n        }\r\n        let endNode = endNeighbors.shift()\r\n        console.log(endNode)\r\n        if (endNode.start) {\r\n            return [visitedPath, getResultPath(grid, endNode)]\r\n        } else {\r\n            if (!endNode.wall || (endNode.start && endNode.wall)) {\r\n                visited.add(endNode.no)\r\n                endCache.add(endNode.no)\r\n                visitedPath.push([endNode.row, endNode.col])\r\n                if (endNode.top != null && !visited.has(grid[endNode.top][endNode.col].no) && !endCache.has(grid[endNode.top][endNode.col].no)) {\r\n                    grid[endNode.top][endNode.col].previous = endNode\r\n                    endCache.add(grid[endNode.top][endNode.col].no)\r\n                    endNeighbors.push(grid[endNode.top][endNode.col])\r\n                } else if (visited.has(grid[endNode.top][endNode.col].no)) {\r\n                    let result = getResultPath(grid, endNode)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[endNode.top][endNode.col]))]\r\n                }\r\n                if (endNode.bottom != null && !visited.has(grid[endNode.bottom][endNode.col].no) && !endCache.has(grid[endNode.bottom][endNode.col].no)) {\r\n                    endCache.add(grid[endNode.bottom][endNode.col].no)\r\n                    grid[endNode.bottom][endNode.col].previous = endNode\r\n                    endNeighbors.push(grid[endNode.bottom][endNode.col])\r\n                } else if (visited.has(grid[endNode.bottom][endNode.col].no)) {\r\n                    let result = getResultPath(grid, endNode)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[endNode.bottom][endNode.col]))]\r\n                }\r\n                if (endNode.left != null && !visited.has(grid[endNode.row][endNode.left].no) && !endCache.has(grid[endNode.row][endNode.left].no)) {\r\n                    endCache.add(grid[endNode.row][endNode.left].no)\r\n                    grid[endNode.row][endNode.left].previous = endNode\r\n                    endNeighbors.push(grid[endNode.row][endNode.left])\r\n                } else if (visited.has(grid[endNode.row][endNode.left])) {\r\n                    let result = getResultPath(grid, endNode)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[endNode.row][endNode.left]))]\r\n                }\r\n                if (endNode.right != null && !visited.has(grid[endNode.row][endNode.right].no) && !endCache.has(grid[endNode.row][endNode.right].no)) {\r\n                    endCache.add(grid[endNode.row][endNode.right].no)\r\n                    grid[endNode.row][endNode.right].previous = endNode\r\n                    endNeighbors.push(grid[endNode.row][endNode.right])\r\n                } else if (visited.has(grid[endNode.row][endNode.right])) {\r\n                    let result = getResultPath(grid, endNode)\r\n                    return [visitedPath, result.concat(getResultPath(grid, grid[endNode.row][endNode.right]))]\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    return [visitedPath, []]\r\n}\r\n\r\n\r\nfunction getResultPath(grid, current) {\r\n    let resultPath = []\r\n    while (grid[current.row][current.col].previous !== null) {\r\n        if (!grid[current.row][current.col].start && !grid[current.row][current.col].end) {\r\n            resultPath.push([current.row, current.col])\r\n        }\r\n        current = grid[current.row][current.col].previous\r\n    }\r\n    return resultPath.reverse()\r\n}\r\n\r\nexport { bfs, dfs, bidirectionalSearch }","import React, { Component } from \"react\";\r\nimport Nodes from \"./Nodes\";\r\nimport \"./Node.css\";\r\nimport update from \"react-addons-update\";\r\nimport Header from './header'\r\n\r\nlet boardWidth\r\nlet boardHeight\r\n\r\n\r\n\r\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n\r\nexport default class PathFindingView extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      board: [],\r\n      mousePressed: false,\r\n      currentGrid: {\r\n        row: -1,\r\n        col: -1,\r\n        start: false,\r\n        end: false,\r\n        previous: null,\r\n        top: null,\r\n        bottom: null,\r\n        left: null,\r\n        right: null,\r\n        wall: false,\r\n        no :-1,\r\n      },\r\n      paused : false,\r\n      algorithm : null,\r\n      startNode : {\r\n        row: 0,\r\n        col: 0,\r\n        start: true,\r\n        end: false,\r\n        previous: null,\r\n        top: null,\r\n        bottom: 1,\r\n        left: null,\r\n        right: 1,\r\n        wall: false,\r\n        no:0\r\n      },\r\n      endNode : {\r\n        row: boardWidth - 1,\r\n        col: boardHeight - 1,\r\n        start: false,\r\n        end: true,\r\n        previous: null,\r\n        top: 18,\r\n        bottom: null,\r\n        left: 58,\r\n        right: null,\r\n        wall: false,\r\n        no: boardHeight * boardWidth - 1\r\n      },\r\n      changed : false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    getRows(window.innerWidth,window.innerHeight)\r\n    const arr = grid();\r\n    this.setState({ board : arr });\r\n  }\r\n\r\n  changeStateFunction(currentNode,cname){\r\n    document.getElementById(`row-${currentNode.row}-col-${currentNode.col}`).className = cname\r\n  }\r\n\r\n  togglePausedFunction(){\r\n    const paused = this.state.paused\r\n    this.setState({\r\n      paused : !paused\r\n    })\r\n  }\r\n\r\n  clearGrid(){\r\n    const grid = this.state.board\r\n    for(let i = 0; i < boardHeight; i++){\r\n      for(let j = 0; j < boardWidth; j++){\r\n        if(!grid[i][j].start && !grid[i][j].end)\r\n        {\r\n          grid[i][j].wall = false\r\n          grid[i][j].visited = false\r\n          grid[i][j].path = false\r\n          grid[i][j].visitedRealTime = false\r\n        }else{\r\n          grid[i][j].wall = false\r\n          grid[i][j].visited = false\r\n          grid[i][j].path = false\r\n          grid[i][j].visitedRealTime = false\r\n        }\r\n      }\r\n    }\r\n    this.setState({board : grid})\r\n  }\r\n\r\n  toggleChanged(condition){\r\n    this.setState({\r\n      changed : condition\r\n    })\r\n  }\r\n\r\n  clearVisited(){\r\n    const grid = this.state.board\r\n    for(let i = 0; i < boardHeight; i++){\r\n      for(let j = 0; j < boardWidth; j++){\r\n        grid[i][j].previous = null\r\n        if(!grid[i][j].start && !grid[i][j].end && !grid[i][j].wall)\r\n        {\r\n          grid[i][j].visited = false\r\n          grid[i][j].path = false\r\n          grid[i][j].visitedRealTime = false\r\n        }else{\r\n          grid[i][j].visited = false\r\n          grid[i][j].path = false\r\n          grid[i][j].visitedRealTime = false\r\n        }\r\n      }\r\n    }\r\n    this.setState({board: grid})\r\n  }\r\n\r\n  getResultArray(resultArray){\r\n    this.animateWalls(resultArray)\r\n  }\r\n\r\n  getVisitedArray(solution){\r\n    if(this.state.changed){\r\n      this.realTimePath(solution[0],solution[1])\r\n    }else{\r\n      this.animatePath(solution[0],solution[1])\r\n    }\r\n  }\r\n\r\n  realTimePath(visitedArray,solutionArray){\r\n    let grid = this.state.board\r\n    for(let index of visitedArray){\r\n      if(!grid[index[0]][index[1]].start && !grid[index[0]][index[1]].end){\r\n        grid[index[0]][index[1]].visitedRealTime = true\r\n      }\r\n    }\r\n    for(let index of solutionArray){\r\n      grid[index[0]][index[1]].visited = false\r\n      grid[index[0]][index[1]].visitedRealTime = false\r\n      grid[index[0]][index[1]].path = true\r\n    }\r\n    this.setState({board : grid})\r\n    this.toggleChanged('false')\r\n  }\r\n\r\n  async animatePath(visitedArray,solutionArray){\r\n    this.togglePausedFunction()\r\n    let grid = this.state.board\r\n    for(let index of visitedArray){\r\n      if(!grid[index[0]][index[1]].start && !grid[index[0]][index[1]].end){\r\n        grid[index[0]][index[1]].visited = true\r\n        grid[index[0]][index[1]].visitedRealTime = false\r\n        grid[index[0]][index[1]].path = true\r\n        this.changeStateFunction(grid[index[0]][index[1]],'Node node-visited')\r\n        await delay(10)\r\n      }\r\n    }\r\n    for(let index of solutionArray){\r\n      grid[index[0]][index[1]].visited = false\r\n      this.changeStateFunction(grid[index[0]][index[1]],'Node node-path')\r\n      await delay(10)\r\n    }\r\n    this.togglePausedFunction()\r\n  }\r\n\r\n  async animateWalls(resultArray){\r\n    this.togglePausedFunction()\r\n    let grid = this.state.board\r\n    for(let index of resultArray){\r\n      grid[index[0]][index[1]].wall = true\r\n      this.changeStateFunction(grid[index[0]][index[1]],'Node node-wall')\r\n      await delay(10)            \r\n    }\r\n    this.togglePausedFunction()\r\n  }\r\n\r\n  updateIndex(rows, cols, content) {\r\n    this.setState(\r\n      update(this.state, {\r\n        board: {\r\n          [rows]: {\r\n            [cols]: {\r\n              $set: content,\r\n            },\r\n          },\r\n        },\r\n        mousePressed: {\r\n          $set: true,\r\n        },\r\n        currentGrid: {\r\n          $set: content,\r\n        },\r\n      })\r\n    );\r\n  }\r\n\r\n  mouseDownFunctions = (rows, cols, e) => {\r\n    if(!this.state.paused){\r\n      const grid = this.state.board;\r\n      if(!grid[rows][cols].start && !grid[rows][cols].end){\r\n        grid[rows][cols].wall = !grid[rows][cols].wall;\r\n        this.updateIndex(rows, cols, grid[rows][cols]);\r\n      }else{\r\n          this.setState({\r\n            mousePressed : true,\r\n            currentGrid : grid[rows][cols]\r\n          })\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  mouseEnterFunction = (rows, cols) => {\r\n    if(!this.state.paused){\r\n      const grid = this.state.board;\r\n      if (!this.state.mousePressed || this.state.currentGrid === grid[rows][cols])\r\n        return;\r\n      if(this.state.currentGrid.start || this.state.currentGrid.end && grid[rows][cols] != this.state.currentGrid ){\r\n        if(!grid[rows][cols].end && !grid[rows][cols].start){\r\n          if(this.state.currentGrid.start && !grid[rows][cols].end){\r\n            grid[rows][cols].start = true\r\n            grid[this.state.currentGrid.row][this.state.currentGrid.col].start = false\r\n            this.setState({\r\n              currentGrid : grid[rows][cols],\r\n              startNode : grid[rows][cols],\r\n              changed : true\r\n            })\r\n          }else if(this.state.currentGrid.end && !grid[rows][cols].start){\r\n            grid[rows][cols].end = true\r\n            grid[this.state.currentGrid.row][this.state.currentGrid.col].end = false\r\n            this.setState({\r\n              currentGrid : grid[rows][cols],\r\n              endNode : grid[rows][cols],\r\n              changed : true\r\n            })\r\n          }\r\n        }\r\n      }else if(!grid[rows][cols].start && !grid[rows][cols].end){\r\n        grid[rows][cols].wall = !grid[rows][cols].wall;\r\n        this.updateIndex(rows, cols, grid[rows][cols]);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  mouseUpFunction = (e) => {\r\n    if(!this.state.paused){\r\n      this.setState({\r\n        mousePressed: false,\r\n        changed : false\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const testing = []\r\n    const grid = this.state.board\r\n    const NodeComponent = this.state.board.map((rows, rowKeys) => {\r\n      return (\r\n        <tr className={`rowIndex-${rowKeys}`}>\r\n          {rows.map((cols, colKeys) => {\r\n            return (\r\n              <Nodes\r\n                id={colKeys}\r\n                row={cols.row}\r\n                col={cols.col}\r\n                wall={cols.wall}\r\n                start={cols.start}\r\n                end = {cols.end}\r\n                visited = {cols.visited}\r\n                visitedRealTime = {cols.visitedRealTime}\r\n                path = {cols.path}\r\n                onMouseDown={(row, col) => this.mouseDownFunctions(row,col)}\r\n                onMouseEnter={(row, col) => this.mouseEnterFunction(row ,col)}\r\n                onMouseUp={() => this.mouseUpFunction()}\r\n              /> \r\n            )\r\n          })}\r\n        </tr>\r\n      )\r\n    });\r\n    return (\r\n      <div>\r\n        <Header\r\n          change = {(newVal,cname)=>this.changeStateFunction(newVal,cname)}\r\n          current = {this.state.board}\r\n          paused = {this.state.paused}\r\n          start = {this.state.startNode}\r\n          end = {this.state.endNode}\r\n          togglePaused = {() => this.togglePausedFunction()}\r\n          sentResult = {(val) => this.getResultArray(val)}\r\n          clearGrid = {() => this.clearGrid()}\r\n          clearVisited = {() => this.clearVisited()}\r\n          sentPath = {(path,result) => this.getVisitedArray(path,result)}\r\n          height = {boardHeight}\r\n          width = {boardWidth}\r\n          change = {this.state.changed}\r\n          toggleChanged = {(condition) => this.toggleChanged(condition)}\r\n        />\r\n        <div className=\"canvas\" unselectable=\"on\">\r\n          {testing}\r\n          <table cellSpacing=\"0\">\r\n            <tbody>\r\n              {NodeComponent}\r\n            </tbody>\r\n          </table>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nconst grid = () => {\r\n  let counter = 0\r\n  const rowArray = [];\r\n  for (let i = 0; i < boardHeight; i++) {\r\n    const colArray = [];\r\n    for (let j = 0; j < boardWidth; j++) {\r\n      colArray.push(createNode(i, j,counter));\r\n      counter++\r\n    }\r\n    rowArray.push(colArray);\r\n  }\r\n  rowArray[0][0].start = true;\r\n  rowArray[rowArray.length - 1][rowArray[0].length - 1].end = true;\r\n  return rowArray;\r\n};\r\n\r\nconst createNode = (i, j, counter) => {\r\n  const NodeObj = {\r\n    row: i,\r\n    col: j,\r\n    start: false,\r\n    end: false,\r\n    previous: null,\r\n    top: i === 0 ? null : i - 1,\r\n    bottom: i === boardHeight - 1 ? null : i + 1,\r\n    left: j === 0 ? null : j - 1,\r\n    right: j === boardWidth - 1 ? null : j + 1,\r\n    wall: false,\r\n    visited : false,\r\n    no: counter,\r\n    path: false,\r\n    visitedRealTime : false\r\n  };\r\n  return NodeObj;\r\n};\r\n\r\nfunction getRows(width,height){\r\n  boardHeight = Math.floor(height / 25)\r\n  boardWidth = Math.floor(width / 25)\r\n}\r\n\r\n\r\n","import React, {Component} from \"react\"\r\nimport \"./Node.css\";\r\nimport recursiveDivisionMaze from './Algorithms/Maze/RecursiveDivision'\r\nimport {bfs, dfs, bidirectionalSearch} from './Algorithms/Search algo/bfs'\r\nexport default class Header extends Component{\r\n    constructor(props){\r\n        super(props)\r\n        this.state = {\r\n            algorithm : 'bfs',\r\n            maze : 'RecursiveMaze',\r\n            selectedAlgorithm : '',\r\n        }\r\n    }\r\n    handleMazeChange = (event) => {\r\n        this.setState({maze : event.target.value})\r\n    }\r\n    handleAlgorithmChange = (event) => {\r\n        this.setState({algorithm : event.target.value, selectedAlgorithm : event.target.value})\r\n    }\r\n\r\n    clearSelectedAlgorithm(){\r\n        this.setState({selectedAlgorithm : ''})\r\n    }\r\n\r\n    searchAlgorithm(algo,grid){\r\n        if(!this.props.paused){\r\n            switch(algo){\r\n                case 'bfs' : this.props.clearVisited()\r\n                this.setState({selectedAlgorithm : 'bfs'})\r\n                this.props.sentPath(bfs(grid,this.props.start))\r\n                break\r\n    \r\n                case 'dfs' : this.props.clearVisited()\r\n                this.setState({selectedAlgorithm : 'dfs'})\r\n                this.props.sentPath(dfs(grid,this.props.start))\r\n                break\r\n\r\n                case 'bdw' : this.props.clearVisited()\r\n                this.setState({selectedAlgorithm : 'bidirectionalSearch'})\r\n                this.props.sentPath(bidirectionalSearch(grid,this.props.start,this.props.end))\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    mazeAlgorithm(algo,grid){\r\n        this.clearSelectedAlgorithm()\r\n        if(!this.props.paused){\r\n            switch(algo){\r\n                case 'RecursiveMaze' : this.props.togglePaused()\r\n                this.props.clearGrid()\r\n                this.props.sentResult(recursiveDivisionMaze(grid,this.props.start,this.props.end,this.props.height,this.props.width))\r\n                break\r\n            }\r\n        }\r\n    }\r\n    render(){\r\n        let clone = Object.assign({},this.props.current)\r\n        let changed = this.props.change\r\n        if(changed === true){\r\n            this.searchAlgorithm(this.state.selectedAlgorithm,clone)\r\n        }\r\n        return(\r\n            <nav className = \"Header\">\r\n                <select onChange={this.handleMazeChange} value ={this.state.maze}>\r\n                    <option value=\"Select an algorithm\">Select an algorithm</option>\r\n                    <option value=\"RecursiveMaze\">Recursive maze generation</option>\r\n                </select>\r\n                <button onClick={() => this.mazeAlgorithm(this.state.maze,clone)}>{this.state.maze}</button>\r\n                <select id=\"algorithms\" onChange={this.handleAlgorithmChange} value ={this.state.algorithm}>\r\n                    <option value=\"bfs\">Breadth First Search</option>\r\n                    <option value =\"dfs\">Depth First Search</option>\r\n                    <option value = \"bdw\">Bidirectional swarm</option>\r\n                </select>\r\n                <button onClick={() => this.searchAlgorithm(this.state.algorithm,clone)}>{this.state.algorithm}</button>\r\n\r\n                <button onClick ={() => {this.props.clearGrid(); this.clearSelectedAlgorithm()}}>Clear Board</button>\r\n                <button onClick={() => {this.props.clearVisited(); this.clearSelectedAlgorithm()}}>Clear Path</button>\r\n            </nav>\r\n        )\r\n    }\r\n}","import React from \"react\"\nimport PathFindingView from './PathFindingView'\n\nclass App extends React.Component {\n    render() {\n        return ( \n            <PathFindingView />\n        )\n    }\n}\n\nexport default App;","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(\n  <App/>,\n  document.getElementById('root')\n)\n\n"],"sourceRoot":""}